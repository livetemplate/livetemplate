package [[.PackageName]]

import (
	"context"
	"fmt"
	"log"
	"math"
	"net/http"
	"sort"
	"strings"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/livefir/livetemplate"
	"[[.ModuleName]]/internal/database/models"
)

var validate = validator.New()

type [[.ResourceName]]Item = models.[[.ResourceNameSingular]]

type AddInput struct {
[[- range .Fields]]
[[- if eq .GoType "bool"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]"`
[[- else if eq .GoType "string"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required,min=3"`
[[- else]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required"`
[[- end]]
[[- end]]
}

type UpdateInput struct {
	ID string `json:"id" validate:"required"`
[[- range .Fields]]
[[- if eq .GoType "bool"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]"`
[[- else if eq .GoType "string"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required,min=3"`
[[- else]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required"`
[[- end]]
[[- end]]
}

type DeleteInput struct {
	ID string `json:"id" validate:"required"`
}

type SearchInput struct {
	Query string `json:"query"`
}

type SortInput struct {
	SortBy string `json:"sort_by"`
}

type PaginationInput struct {
	Page int `json:"page" validate:"required,min=1"`
}

type [[.ResourceName]]State struct {
	Title        string                `json:"title"`
	Queries      *models.Queries       `json:"-"`
	SearchQuery  string                `json:"search_query"`
	SortBy       string                `json:"sort_by"`
	Filtered[[.ResourceName]]s  [][[.ResourceName]]Item `json:"filtered_[[.ResourceNameLower]]s"`
	CurrentPage  int                   `json:"current_page"`
	PageSize     int                   `json:"page_size"`
	TotalPages   int                   `json:"total_pages"`
	Paginated[[.ResourceName]]s [][[.ResourceName]]Item `json:"paginated_[[.ResourceNameLower]]s"`
	TotalCount   int                   `json:"total_count"`
	LastUpdated  string                `json:"last_updated"`
	EditingID    string                `json:"editing_id"`
	Editing[[.ResourceName]] *[[.ResourceName]]Item   `json:"editing_[[.ResourceNameLower]]"`
}

func (s *[[.ResourceName]]State) Change(ctx *livetemplate.ActionContext) error {
	dbCtx := context.Background()

	switch ctx.Action {
	case "add":
		var input AddInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}

		now := time.Now()
		id := fmt.Sprintf("[[.ResourceNameLower]]-%d", now.UnixNano())

		_, err := s.Queries.Create[[.ResourceNameSingular]](dbCtx, models.Create[[.ResourceNameSingular]]Params{
			ID:        id,
[[- range .Fields]]
			[[.Name | camelCase]]: input.[[.Name | camelCase]],
[[- end]]
			CreatedAt: now,
		})
		if err != nil {
			return fmt.Errorf("failed to create [[.ResourceNameLower]]: %w", err)
		}

		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "edit":
		var input DeleteInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}

		// Find the item to edit
		[[.ResourceNameLower]]s, err := s.Queries.GetAll[[.ResourceNamePlural]](dbCtx)
		if err != nil {
			return fmt.Errorf("failed to load [[.ResourceNameLower]]s: %w", err)
		}

		for _, item := range [[.ResourceNameLower]]s {
			if item.ID == input.ID {
				s.EditingID = input.ID
				itemCopy := item
				s.Editing[[.ResourceName]] = &itemCopy
				break
			}
		}

	case "update":
		var input UpdateInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}

		err := s.Queries.Update[[.ResourceNameSingular]](dbCtx, models.Update[[.ResourceNameSingular]]Params{
			ID: input.ID,
[[- range .Fields]]
			[[.Name | camelCase]]: input.[[.Name | camelCase]],
[[- end]]
		})
		if err != nil {
			return fmt.Errorf("failed to update [[.ResourceNameLower]]: %w", err)
		}

		// Clear editing state
		s.EditingID = ""
		s.Editing[[.ResourceName]] = nil

		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "cancel_edit":
		s.EditingID = ""
		s.Editing[[.ResourceName]] = nil

	case "delete":
		var input DeleteInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}

		err := s.Queries.Delete[[.ResourceNameSingular]](dbCtx, input.ID)
		if err != nil {
			return fmt.Errorf("failed to delete [[.ResourceNameLower]]: %w", err)
		}

		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "search":
		var input SearchInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}
		s.SearchQuery = input.Query

		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "sort":
		var input SortInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}
		s.SortBy = input.SortBy

		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "next_page":
		if s.CurrentPage < s.TotalPages {
			s.CurrentPage++
		}
		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "prev_page":
		if s.CurrentPage > 1 {
			s.CurrentPage--
		}
		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	case "goto_page":
		var input PaginationInput
		if err := ctx.BindAndValidate(&input, validate); err != nil {
			return err
		}
		if input.Page >= 1 && input.Page <= s.TotalPages {
			s.CurrentPage = input.Page
		}
		if err := s.load[[.ResourceName]]s(dbCtx); err != nil {
			return err
		}

	default:
		log.Printf("Unknown action: %s", ctx.Action)
		return nil
	}

	s.LastUpdated = formatTime()
	return nil
}

func (s *[[.ResourceName]]State) Init() error {
	return s.load[[.ResourceName]]s(context.Background())
}

func (s *[[.ResourceName]]State) load[[.ResourceName]]s(ctx context.Context) error {
	[[.ResourceNameLower]]s, err := s.Queries.GetAll[[.ResourceNamePlural]](ctx)
	if err != nil {
		return fmt.Errorf("failed to load [[.ResourceNameLower]]s: %w", err)
	}

	if s.SearchQuery == "" {
		s.Filtered[[.ResourceName]]s = [[.ResourceNameLower]]s
	} else {
		s.Filtered[[.ResourceName]]s = [][[.ResourceName]]Item{}
		query := strings.ToLower(s.SearchQuery)
		for _, item := range [[.ResourceNameLower]]s {
			// Search across all text fields
[[- range .Fields]]
[[- if eq .GoType "string"]]
			if strings.Contains(strings.ToLower(item.[[.Name | camelCase]]), query) {
				s.Filtered[[$.ResourceName]]s = append(s.Filtered[[$.ResourceName]]s, item)
				continue
			}
[[- end]]
[[- end]]
		}
	}

	s.TotalCount = len([[.ResourceNameLower]]s)
	s.applySorting()
	s.applyPagination()

	return nil
}

func (s *[[.ResourceName]]State) applySorting() {
	switch s.SortBy {
[[- range .Fields]]
[[- if eq .GoType "string"]]
	case "[[.Name]]_asc":
		sort.Slice(s.Filtered[[$.ResourceName]]s, func(i, j int) bool {
			return strings.ToLower(s.Filtered[[$.ResourceName]]s[i].[[.Name | camelCase]]) < strings.ToLower(s.Filtered[[$.ResourceName]]s[j].[[.Name | camelCase]])
		})
	case "[[.Name]]_desc":
		sort.Slice(s.Filtered[[$.ResourceName]]s, func(i, j int) bool {
			return strings.ToLower(s.Filtered[[$.ResourceName]]s[i].[[.Name | camelCase]]) > strings.ToLower(s.Filtered[[$.ResourceName]]s[j].[[.Name | camelCase]])
		})
[[- end]]
[[- end]]
	case "oldest_first":
		sort.Slice(s.Filtered[[.ResourceName]]s, func(i, j int) bool {
			return s.Filtered[[.ResourceName]]s[i].CreatedAt.Before(s.Filtered[[.ResourceName]]s[j].CreatedAt)
		})
	default:
		sort.Slice(s.Filtered[[.ResourceName]]s, func(i, j int) bool {
			return s.Filtered[[.ResourceName]]s[i].CreatedAt.After(s.Filtered[[.ResourceName]]s[j].CreatedAt)
		})
	}
}

func (s *[[.ResourceName]]State) applyPagination() {
	if len(s.Filtered[[.ResourceName]]s) == 0 {
		s.TotalPages = 1
		s.CurrentPage = 1
		s.Paginated[[.ResourceName]]s = [][[.ResourceName]]Item{}
		return
	}

	s.TotalPages = int(math.Ceil(float64(len(s.Filtered[[.ResourceName]]s)) / float64(s.PageSize)))

	if s.CurrentPage < 1 {
		s.CurrentPage = 1
	}
	if s.CurrentPage > s.TotalPages {
		s.CurrentPage = s.TotalPages
	}

	start := (s.CurrentPage - 1) * s.PageSize
	end := start + s.PageSize
	if end > len(s.Filtered[[.ResourceName]]s) {
		end = len(s.Filtered[[.ResourceName]]s)
	}

	s.Paginated[[.ResourceName]]s = s.Filtered[[.ResourceName]]s[start:end]
}

func formatTime() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// Handler creates an http.Handler for this resource
func Handler(queries *models.Queries) http.Handler {
	state := &[[.ResourceName]]State{
		Title:       "[[.ResourceName]] Management",
		Queries:     queries,
		CurrentPage: 1,
		PageSize:    10,
		LastUpdated: formatTime(),
	}

	if err := state.Init(); err != nil {
		log.Printf("Failed to initialize [[.ResourceNameLower]] state: %v", err)
	}

	tmpl := livetemplate.New("[[.ResourceNameLower]]")
	if _, err := tmpl.ParseFiles("internal/app/[[.ResourceNameLower]]/[[.ResourceNameLower]].tmpl"); err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	return livetemplate.Mount(tmpl, state)
}
