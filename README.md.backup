# LiveTemplate

Build real-time, reactive web applications in Go with minimal code. LiveTemplate uses tree-based DOM diffing to send only what changed over HTTP (with optional WebSocket for broadcasts), inspired by Phoenix LiveView.

**[Quick Start](#quick-start)** ‚Ä¢ **[API Docs](https://pkg.go.dev/github.com/livefir/livetemplate)** ‚Ä¢ **[Client Reference](docs/references/client-attributes.md)** ‚Ä¢ **[CLI Tool](#cli-tool-lvt)** ‚Ä¢ **[Contributing](CONTRIBUTING.md)**

---

> **‚ö†Ô∏è ALPHA SOFTWARE WARNING**
>
> LiveTemplate is currently in **alpha stage** and **not ready for production use**. The API is stabilizing but may still change. Expect bugs, incomplete features, and breaking changes. Use in production at your own risk.
>
> - ‚úÖ Core features work and are tested
> - ‚ö†Ô∏è API may change before v1.0
> - üöß Some planned features not yet implemented (see design docs)
> - üêõ Report issues at [github.com/livefir/livetemplate/issues](https://github.com/livefir/livetemplate/issues)

---

## Why LiveTemplate?

LiveTemplate brings Phoenix LiveView's developer experience to Go:

- **Server-side state** - Your state lives in Go, not scattered across client and server
- **Automatic updates** - Change state, UI updates automatically. No manual DOM manipulation
- **Ultra-efficient** - Tree-based diffing sends 50-90% less data than full HTML
- **Type-safe** - Leverage Go's type system for your entire application
- **Zero frontend build** - No webpack, no npm dependencies for your app
- **Rich features** - Built-in validation, session management, and error handling
- **Full-stack CLI** - `lvt` tool generates complete CRUD apps with routing, database, and migrations

### When to Use LiveTemplate

**Perfect for:**
- Admin dashboards and internal tools
- Real-time collaborative features
- Forms with complex validation
- Server-side state is your source of truth
- Teams that prefer Go over JavaScript frameworks

**Consider alternatives if:**
- You need offline-first capabilities
- Heavy client-side interactions (games, drawing apps)
- Mobile app with native feel
- SEO is critical and SSR isn't enough

## Quick Start

### Installation

```bash
go get github.com/livefir/livetemplate
```

### Your First App (5 minutes)

**1. Create your state**

```go
// main.go
package main

import (
    "net/http"
    "github.com/livefir/livetemplate"
)

type CounterState struct {
    Counter int `json:"counter"`
}

func (s *CounterState) Change(ctx *livetemplate.ActionContext) error {
    switch ctx.Action {
    case "increment":
        s.Counter++
    case "decrement":
        s.Counter--
    case "reset":
        s.Counter = 0
    }
    return nil
}

func main() {
    state := &CounterState{Counter: 0}
    tmpl := livetemplate.New("counter")

    http.Handle("/", tmpl.Handle(state))
    http.ListenAndServe(":8080", nil)
}
```

**2. Create your template**

```html
<!-- counter.tmpl -->
<!DOCTYPE html>
<html>
<head>
    <title>Counter</title>
</head>
<body>
    <h1>Counter: {{.Counter}}</h1>
    <button lvt-click="increment">+</button>
    <button lvt-click="decrement">-</button>
    <button lvt-click="reset">Reset</button>

    <script src="https://cdn.jsdelivr.net/npm/@livefir/livetemplate-client@latest/dist/livetemplate-client.min.js"></script>
</body>
</html>
```

**3. Run it**

```bash
go run main.go
# Open http://localhost:8080
```

That's it! Click buttons and watch the counter update in real-time.

**Learn More:**
- [Go API Reference](https://pkg.go.dev/github.com/livefir/livetemplate) - Complete server-side API documentation
- [Client Attributes](docs/references/client-attributes.md) - Event bindings and client-side features

## How It Works

```
User clicks button ‚Üí Client sends action ‚Üí Server updates state ‚Üí
Server renders template ‚Üí Tree diff ‚Üí Minimal update ‚Üí Client applies patch
```

1. **Define state**: Your Go struct holds application state
2. **Handle actions**: Implement [`Store`](https://pkg.go.dev/github.com/livefir/livetemplate#Store) interface with `Change(ctx)` method
3. **Render template**: Use standard Go templates with [`lvt-*` attributes](#event-bindings)
4. **Automatic updates**: LiveTemplate handles the rest

### WebSocket is Optional

**Important:** WebSocket is NOT required for LiveTemplate to work. All features work perfectly over regular HTTP:

- ‚úÖ **State management** - Works over HTTP
- ‚úÖ **Form handling** - Works over HTTP
- ‚úÖ **Validation** - Works over HTTP
- ‚úÖ **Tree-based updates** - Works over HTTP
- ‚úÖ **Event bindings** - Works over HTTP
- ‚ö° **Broadcasting** - Requires WebSocket (server-initiated updates)

**HTTP Mode:**
- Client sends actions via HTTP POST
- Server responds with tree updates
- Simple, stateless, works everywhere
- Great for forms, CRUD operations, and most use cases

**WebSocket Mode:**
- Persistent connection for instant updates
- Required only for server-initiated broadcasts
- Automatic fallback to HTTP if WebSocket unavailable
- Ideal for real-time collaboration, live notifications

**Default behavior:** LiveTemplate automatically uses WebSocket when available, falls back to HTTP otherwise. You don't need to change your code.

## Comparison with Other Frameworks

| Feature | LiveTemplate | Phoenix LiveView | Datastar | HTMX | Hotwire Turbo |
|---------|-------------|------------------|----------|------|---------------|
| **Language** | Go | Elixir | Any backend | Any backend | Any backend |
| **State Management** | Server-side | Server-side | Hybrid | Server-side | Server-side |
| **Transport** | HTTP (WS optional) | WebSocket | SSE/Fetch | HTTP | HTTP |
| **Update Method** | Tree diffing | DOM patches | Signals | HTML replacement | HTML replacement |
| **Data Sent** | Minimal JSON tree | Binary diff | HTML + signals | Full/partial HTML | Full HTML |
| **Type Safety** | Yes (Go) | Yes (Elixir) | Backend dependent | Backend dependent | Backend dependent |
| **Validation** | Server-side | Server-side | Server or client | Server-side | Server-side |
| **Code Generation** | Yes (`lvt` CLI) | Yes (Phoenix generators) | No | No | No |
| **Client Size** | ~15KB | ~50KB | ~10KB | ~14KB | ~30KB |
| **Maturity** | Alpha | Production | Alpha | Production | Production |

### Key Differentiators

**vs Phoenix LiveView**
- Same LiveView pattern, different language (Go vs Elixir)
- Single binary deployment vs BEAM VM
- Both have code generation: `lvt` CLI vs Phoenix generators
- Tree-based JSON updates vs binary DOM patches

**vs HTMX**
- Both use HTTP by default (LiveTemplate adds optional WebSocket for broadcasts)
- LiveTemplate sends minimal JSON trees, HTMX sends full/partial HTML
- LiveTemplate has built-in state management and `lvt` code generator
- HTMX is simpler for basic HTML-over-wire patterns

**vs Datastar**
- Both inspired by LiveView with similar goals
- LiveTemplate: HTTP + tree diffing, Datastar: SSE + signals
- LiveTemplate focused on Go with `lvt` CLI, Datastar language-agnostic
- Different technical approaches to the same problem

**vs Hotwire Turbo**
- Different use cases: LiveTemplate for reactive UIs, Turbo for page navigation
- LiveTemplate sends minimal updates, Turbo replaces entire pages/frames
- Both use HTTP, complementary tools for different needs

## Features

LiveTemplate provides rich client-side features through `lvt-*` HTML attributes.

**üìñ [Complete Client Attributes Reference ‚Üí](docs/references/client-attributes.md)**

### Quick Examples

**Event bindings:**
```html
<button lvt-click="submit">Submit</button>
<form lvt-submit="save">...</form>
<input lvt-input="search" lvt-debounce="300" name="query">
```

**Pass data to actions:**
```html
<button lvt-click="delete" lvt-data-id="{{.ID}}">Delete</button>
```

**Access data in Go:**
```go
func (s *State) Change(ctx *livetemplate.ActionContext) error {
    id := ctx.GetString("id")  // From lvt-data-id
    // Handle action
}
```

**Server-side validation:**
```go
func (s *State) Change(ctx *livetemplate.ActionContext) error {
    var input TodoInput
    if err := ctx.BindAndValidate(&input, validate); err != nil {
        return err // Errors shown automatically in template
    }
}
```

**Form lifecycle events:**
```javascript
form.addEventListener('lvt:success', (e) => {
    console.log('Action completed successfully!');
});
```

**Multi-store pattern:**
```html
<button lvt-click="counter.increment">+</button>
<button lvt-click="todos.add">Add Todo</button>
```

For complete documentation of all `lvt-*` attributes, event bindings, validation, and advanced patterns, see the **[Client Attributes Reference](docs/references/client-attributes.md)**.

### Broadcasting (Server-Initiated Updates)

Push updates from the server to connected clients without user interaction:

```go
type ChatState struct {
    Messages    []Message
    broadcaster livetemplate.Broadcaster
}

// Implement BroadcastAware to receive broadcaster on connection
func (s *ChatState) OnConnect(ctx context.Context, b livetemplate.Broadcaster) error {
    s.broadcaster = b

    // Optional: Start background tasks for server-initiated updates
    go s.listenForNotifications(ctx)

    return nil
}

func (s *ChatState) OnDisconnect() {
    s.broadcaster = nil
}

// User action updates state normally
func (s *ChatState) Change(ctx *livetemplate.ActionContext) error {
    switch ctx.Action {
    case "send":
        msg := Message{
            Text: ctx.GetString("text"),
            Time: time.Now(),
        }
        s.Messages = append(s.Messages, msg)
        // Update sent automatically to this connection
    }
    return nil
}

// Server-initiated update (background job, webhook, external event)
func (s *ChatState) NotifyNewMessage(msg Message) {
    s.Messages = append(s.Messages, msg)

    // Push update to this connection
    if s.broadcaster != nil {
        s.broadcaster.Send()
    }
}

func (s *ChatState) listenForNotifications(ctx context.Context) {
    // Example: Listen for external events and push updates
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            // Fetch new messages from external source
            // then push update
            if s.broadcaster != nil {
                s.broadcaster.Send()
            }
        }
    }
}
```

**Note:** Current implementation broadcasts to individual connections. Multi-user broadcasting across all sessions is planned but not yet implemented (see `docs/design/multi-session-isolation.md`).

### Tree-Based Optimization

LiveTemplate achieves 50-90% bandwidth savings through tree diffing:

**First render (full tree with statics):**
```json
{
    "s": ["<div>Counter: ", "</div>"],
    "0": "5"
}
```

**Subsequent updates (only changed dynamics):**
```json
{
    "0": "6"
}
```

Static parts (`s`) are cached client-side and referenced by ID. For templates with lots of static HTML and few dynamic values, this is extremely efficient.

## Examples

### Counter
Simple increment/decrement counter demonstrating basic state management.

```bash
cd examples/counter
go run main.go
# Open http://localhost:8080
```

### Todos
Full CRUD application with validation, forms, and lifecycle events.

```bash
cd examples/todos
go run main.go
# Open http://localhost:8080
```

### Source Code
Both examples are ~100 lines of Go + template. See `examples/` directory for complete code.

## CLI Tool (`lvt`)

**Key Differentiator:** The `lvt` CLI generates complete, production-ready CRUD applications with routing, database integration, migrations, and your choice of CSS framework - all from a single command.

Unlike most Go web frameworks, LiveTemplate includes a full-stack code generator that scaffolds entire applications, not just boilerplate.

### Installation

```bash
go install github.com/livefir/livetemplate/cmd/lvt@latest
```

### Quick Start

```bash
# Create new app with Tailwind CSS
lvt new myapp --css tailwind
cd myapp

# Generate CRUD resource
lvt gen products name price:float stock:int

# Start dev server with hot reload
lvt serve
```

### Features

- **App Scaffolding**: Generate complete apps with routing and database
- **CRUD Generation**: Instant CRUD with forms, validation, tables
- **CSS Kits**: Tailwind, Bulma, Pico, or plain HTML (includes reusable components)
- **Hot Reload**: Auto-rebuild and restart on file changes
- **Database Migrations**: Built-in migration management

### Commands

```bash
# App commands
lvt new <name>                 # Create new app
lvt gen <resource> [fields]    # Generate CRUD resource
lvt gen view <name>            # Generate view-only handler

# Development
lvt serve                      # Start dev server with hot reload

# Kits
lvt kits list                  # List available CSS kits
lvt kits create <name>         # Create custom kit

# Database
lvt migration up               # Run migrations
lvt migration down             # Rollback migrations
lvt migration status           # Show migration status
```

### CLI Documentation

Full CLI documentation:
- **[User Guide](docs/guides/user-guide.md)** - Getting started with CLI
- **[Kit Development](docs/guides/kit-development.md)** - Creating CSS kits (includes components)
- **[Serve Guide](docs/guides/serve-guide.md)** - Development server

## Client Library

The TypeScript client handles HTTP/WebSocket communication, event delegation, and DOM updates.

### CDN

```html
<script src="https://cdn.jsdelivr.net/npm/@livefir/livetemplate-client@latest/dist/livetemplate-client.min.js"></script>
```

### Build from Source

```bash
cd client
npm install
npm run build
```

The client (~15KB minified):
- Uses HTTP by default for actions and updates
- Optionally connects via WebSocket for server-initiated broadcasts
- Automatic reconnection and error handling
- Handles event delegation for `lvt-*` attributes
- Applies DOM updates efficiently using morphdom
- Manages form lifecycle and validation errors
- Preserves input focus and scroll position

## Documentation

### References
- **[Go API Reference](https://pkg.go.dev/github.com/livefir/livetemplate)** - Server-side Go API (types, functions, interfaces)
- **[Client Attributes Reference](docs/references/client-attributes.md)** - `lvt-*` attributes, event bindings, validation
- **[Error Handling Reference](docs/references/error-handling.md)** - Validation, error display, client-side handling
- **[Template Support Matrix](docs/references/template-support-matrix.md)** - Supported Go template features
- **[Manifest Schemas](docs/references/api-reference.md)** - Kit YAML schemas

### Guides
- **[User Guide](docs/guides/user-guide.md)** - Getting started with `lvt` CLI
- **[Code Tour](docs/guides/CODE_TOUR.md)** - Guided walkthrough of the codebase
- **[Kit Development](docs/guides/kit-development.md)** - Creating CSS framework kits (includes components)
- **[Serve Guide](docs/guides/serve-guide.md)** - Development server usage

### Design
- **[Architecture](docs/ARCHITECTURE.md)** - System architecture and design decisions
- **[Code Structure](docs/CODE_STRUCTURE.md)** - Codebase organization
- **[Multi-Session Isolation](docs/design/multi-session-isolation.md)** - Planned authentication and session features

## Testing

```bash
# Run all tests
go test -v ./...

# Run specific test suite
go test -run TestTemplate_E2E -v

# Run client tests
cd client && npm test

# Run with coverage
go test -v -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

## Contributing

We welcome contributions! See [CONTRIBUTING.md](CONTRIBUTING.md) for:
- Development setup
- Testing guidelines
- Code style conventions
- PR process

## Roadmap

- [ ] Stable v1.0 release
- [ ] Performance benchmarks vs alternatives
- [ ] Deployment guides (Docker, Kubernetes, serverless)
- [ ] Advanced examples (real-time chat, collaborative editing)
- [ ] Streaming updates for large datasets
- [ ] Client-side caching improvements
- [ ] Developer tools (browser extension)

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Acknowledgments

Inspired by [Phoenix LiveView](https://hexdocs.pm/phoenix_live_view) - bringing that developer experience to Go.

## Community

- **GitHub Issues**: Bug reports and feature requests
- **GitHub Discussions**: Questions and community discussion
- **Examples**: Check `examples/` directory for working code

---

**Built with LiveTemplate?** We'd love to hear about it! Share your project in GitHub Discussions.
