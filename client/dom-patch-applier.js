/**
 * DOM Patch Applier - Phoenix LiveView inspired client-side patch application
 * 
 * This client applies DOM patches generated by the server's DOMDiffer.
 * Unlike the current tree-based approach, this uses standard DOM APIs
 * and CSS selectors for maximum compatibility.
 */

class DOMPatchApplier {
    constructor() {
        this.debug = false; // Set to true for detailed logging
    }

    /**
     * Apply a patch received from the server
     * @param {Object} patch - The patch object with operations
     */
    applyPatch(patch) {
        if (!patch || !patch.operations) {
            console.warn('Invalid patch received:', patch);
            return;
        }

        if (this.debug) {
            console.log(`Applying patch for fragment: ${patch.fragment_id}`, patch);
        }

        for (const operation of patch.operations) {
            try {
                this.applyOperation(operation);
            } catch (error) {
                console.error('Failed to apply operation:', operation, error);
            }
        }

        if (this.debug) {
            console.log(`Applied ${patch.operations.length} operations successfully`);
        }
    }

    /**
     * Apply a single patch operation
     * @param {Object} operation - The operation to apply
     */
    applyOperation(operation) {
        const { type, selector, key, value, html } = operation;

        if (this.debug) {
            console.log(`Applying ${type} operation:`, operation);
        }

        switch (type) {
            case 'setAttribute':
                this.setAttribute(selector, key, value);
                break;
            
            case 'removeAttribute':
                this.removeAttribute(selector, key);
                break;
            
            case 'setTextContent':
                this.setTextContent(selector, value);
                break;
            
            case 'replaceElement':
                this.replaceElement(selector, html);
                break;
            
            case 'insertElement':
                this.insertElement(selector, html);
                break;
            
            case 'removeElement':
                this.removeElement(selector);
                break;
            
            default:
                console.warn('Unknown operation type:', type);
        }
    }

    /**
     * Set an attribute on the selected element
     */
    setAttribute(selector, key, value) {
        const element = this.findElement(selector);
        if (element) {
            // Handle special cases for input elements
            if (element.tagName === 'INPUT' && key === 'value') {
                // Set both attribute and property for input values
                element.setAttribute(key, value);
                element.value = value;
            } else {
                element.setAttribute(key, value);
            }
            
            if (this.debug) {
                console.log(`Set ${key}="${value}" on:`, element);
            }
        }
    }

    /**
     * Remove an attribute from the selected element
     */
    removeAttribute(selector, key) {
        const element = this.findElement(selector);
        if (element) {
            element.removeAttribute(key);
            
            if (this.debug) {
                console.log(`Removed ${key} from:`, element);
            }
        }
    }

    /**
     * Set text content of the selected element
     */
    setTextContent(selector, value) {
        const element = this.findElement(selector);
        if (element) {
            // Use textContent to avoid HTML injection and Google Translate issues
            element.textContent = value;
            
            if (this.debug) {
                console.log(`Set text content to "${value}" on:`, element);
            }
        }
    }

    /**
     * Replace an element with new HTML
     */
    replaceElement(selector, html) {
        const element = this.findElement(selector);
        if (element) {
            // Create a temporary container to parse the HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // If we got multiple elements, wrap them
            const newContent = temp.children.length === 1 ? 
                temp.firstElementChild : 
                temp;
            
            element.parentNode.replaceChild(newContent, element);
            
            if (this.debug) {
                console.log(`Replaced element with:`, newContent);
            }
        }
    }

    /**
     * Insert an element at the selector position
     */
    insertElement(selector, html) {
        const parent = this.findParentElement(selector);
        if (parent) {
            const temp = document.createElement('div');
            temp.innerHTML = html;
            const newElement = temp.firstElementChild;
            
            // Insert at the appropriate position based on selector
            // This is a simplified implementation
            parent.appendChild(newElement);
            
            if (this.debug) {
                console.log(`Inserted element:`, newElement);
            }
        }
    }

    /**
     * Remove the selected element
     */
    removeElement(selector) {
        const element = this.findElement(selector);
        if (element && element.parentNode) {
            element.parentNode.removeChild(element);
            
            if (this.debug) {
                console.log(`Removed element:`, element);
            }
        }
    }

    /**
     * Find an element using our simplified selector system
     * This handles the selectors generated by our DOM differ
     */
    findElement(selector) {
        try {
            if (!selector || selector === 'body') {
                return document.body;
            }

            // Handle our simple nth-child selector format: "div > :nth-child(2) > :nth-child(1)"
            return this.resolveNestedSelector(document.body, selector);
            
        } catch (error) {
            console.error('Failed to find element with selector:', selector, error);
            return null;
        }
    }

    /**
     * Find parent element for insertion operations
     */
    findParentElement(selector) {
        const parts = selector.split(' > ');
        if (parts.length > 1) {
            const parentSelector = parts.slice(0, -1).join(' > ');
            return this.findElement(parentSelector);
        }
        return document.body;
    }

    /**
     * Resolve a nested selector like "div > :nth-child(2) > :nth-child(1)"
     */
    resolveNestedSelector(root, selector) {
        const parts = selector.trim().split(' > ');
        let current = root;

        for (const part of parts) {
            if (!current) return null;

            if (part.startsWith(':nth-child(')) {
                // Extract the index from :nth-child(n)
                const match = part.match(/nth-child\((\d+)\)/);
                if (match) {
                    const index = parseInt(match[1]) - 1; // Convert to 0-based
                    const children = this.getElementChildren(current);
                    current = children[index] || null;
                }
            } else if (part && part !== ':nth-child()') {
                // Tag name selector
                current = current.querySelector(part);
            }
        }

        return current;
    }

    /**
     * Get element children, excluding text nodes with only whitespace
     */
    getElementChildren(element) {
        const children = [];
        for (const child of element.childNodes) {
            // Include element nodes and non-empty text nodes
            if (child.nodeType === Node.ELEMENT_NODE || 
                (child.nodeType === Node.TEXT_NODE && child.textContent.trim())) {
                children.push(child);
            }
        }
        return children;
    }

    /**
     * Enable debug logging
     */
    enableDebug() {
        this.debug = true;
        console.log('DOM Patch Applier debug enabled');
    }

    /**
     * Disable debug logging
     */
    disableDebug() {
        this.debug = false;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DOMPatchApplier;
}

// Global instance for easy access
window.DOMPatchApplier = DOMPatchApplier;

// Auto-initialize if LiveTemplate is present
if (window.LiveTemplate) {
    window.LiveTemplate.domPatchApplier = new DOMPatchApplier();
    console.log('DOM Patch Applier initialized with LiveTemplate');
}